package maersk.com.mq.cpuevents;

/*
 * Copyright 2020
 * Maersk
 *
 * https://community.ibm.com/community/user/imwuc/viewdocument/a-first-look-at-mq-resource-usage-s?CommunityKey=183ec850-4947-49c8-9a2e-8e7c7fc46c64&tab=librarydocuments
 *
 * Get MQ CPU events
 * 
 * 01/07/2020 - Get MQ CPU events
 *            - Events are generated by creating an subscription to the following topic ..
 *            - $SYS/MQ/INFO/QMGR/QMAP01/Monitor/CPU/SystemSummary &
 *            - $SYS/MQ/INFO/QMGR/QMAP01/Monitor/CPU/QMgrSummary
 * 
 */

import java.io.IOException;
import java.net.MalformedURLException;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.ibm.mq.MQException;
import com.ibm.mq.MQGetMessageOptions;
import com.ibm.mq.MQMessage;
import com.ibm.mq.MQQueue;
import com.ibm.mq.MQQueueManager;
import com.ibm.mq.constants.MQConstants;
import com.ibm.mq.headers.MQDataException;
import com.ibm.mq.headers.pcf.PCFMessage;
import com.ibm.mq.headers.pcf.PCFParameter;

import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tags;
import maersk.com.mq.events.IMQPCFConstants;
import maersk.com.mq.events.IEvents;
import maersk.com.mq.events.MQMetricsQueueManager;

@Component
public class CPUEvents implements Callable<Integer>, IEvents, IMQPCFConstants {

	private final static Logger log = LoggerFactory.getLogger(CPUEvents.class);
	
	@Autowired
	public MeterRegistry meterRegistry;

    @Autowired
    private MQMetricsQueueManager metricsqueuemanager;
    private MQMetricsQueueManager MetricsQueueManager() {
    	return this.metricsqueuemanager;
    }
	
    //@Autowired
    private MQQueueManager queManager;
    public void QueueManager(MQQueueManager qm) {
    	this.queManager = qm;
    }
    public MQQueueManager QueueManager() {
    	return this.queManager;
    }
	    
	private String queuemanagername;
	public void QueueManagerName(String v) {
		this.queuemanagername = v;
	}
	public String QueueManagerName() {
		return this.queuemanagername;
	}
	
    @Value("${ibm.mq.event.delayInMilliSeconds}")
	private int resetIterations;

    @Value("${ibm.mq.event.cpu.queue:CPU_QMGR}")
    private String queueName;
    public String QueueName() {
    	return this.queueName;	
    }
    
    private MQQueue queue;
    public MQQueue Queue() {
    	return this.queue;
    }
    public void Queue(MQQueue v) {
    	this.queue = v;
    }

    private MQGetMessageOptions gmo;
    public MQGetMessageOptions GetMessageOptions() {
    	return this.gmo;
    }
    public void GetMessageOptions(MQGetMessageOptions v) {
    	this.gmo = v;
    }

    @Value("#{new Boolean('${ibm.mq.broswe:true}')}")
    private Boolean browse;
    public Boolean Browse() {
    	return this.browse;
    }

    @Value("#{new Integer('${ibm.mq.event.waitInterval:5000}')}")    
    private Integer waitinterval;
    public Integer WaitInterval() {
    	return this.waitinterval;
    }
    
    private Map<String,AtomicInteger>CPUEventsMap = new HashMap<String,AtomicInteger>();
    private Map<String,AtomicLong>CPUIntervalMap = new HashMap<String,AtomicLong>();
    protected static final String lookupcpu = "mq:cpuStatus";
    	
	private int taskstatus;
	private void TaskStatus(int v) {
		this.taskstatus = v;
	}
	public int TaskStatus() {
		return this.taskstatus;
	}

	private int retcode;
	public void RetCode(int v) {
		this.retcode = v;
	}
	public int RetCode() {
		return this.retcode;
	}
	
	private GregorianCalendar cal;
	private int hour;
	private void Hour(int v) {
		this.hour = v;
	}
	private int Hour() {
		return this.hour;
	}
	private int day;
	private void Day(int v) {
		this.day = v;
	}
	private int Day() {
		return this.day;
	}
	private int month;
	private void Month(int v) {
		this.month = v;
	}
	private int Month() {
		return this.month;
	}
	private int year;
	private void Year(int v) {
		this.year = v;
	}
	private int Year() {
		return this.year;
	}
	
    @Value("${ibm.mq.event.cpu.type:QMgrSummary}")
	private String eventtype;
    public String EventType() {
    	return eventtype;
    }
	
	@Override
    @PostConstruct
	public void Init() throws MQException, MalformedURLException, MQDataException {
		log.info("cpuevents: Init");
		TaskStatus(IMQPCFConstants.TASK_STOPPED);
	}

	@Override
	public Integer call() throws MQException, MQDataException, IOException, InterruptedException {
		QueueManager(MetricsQueueManager().CreateQueueManager());
		QueueManagerName(QueueManager().getName().trim());
		RetCode(IMQPCFConstants.OKAY);
		
    	RunTask();		
    	return RetCode();
	}
	
	@Override
	public void RunTask() throws MQException, MQDataException, IOException, InterruptedException {
	   	log.debug("cpuevents: RunTask");

    	/*
    	 * Open the queue
    	 */
		try {
			Queue(null);
			OpenQueueForReading();
			
		} catch (MQException e) {
			log.error("Unable to open queue {}, reason: {}", QueueName(), e.getReason());
			RetCode(e.getReason());
			throw new MQException(e.getCompCode(), e.getReason(), e);

		}

		/*
		 * Process messages
		 */
		try {
			ReadEventsFromQueue();
			
		} catch (MQException e) {
			log.debug("Unable to read messages from " + QueueName());
			RetCode(e.getReason());
			
		} catch (MQDataException e) {
			log.debug("Unable to read messages from " + QueueName());
			RetCode(e.getReason());
			
		} catch (IOException e) {
			log.debug("Unable to read messages from " + QueueName());
			RetCode(IMQPCFConstants.RET_WITH_ERROR);
		}
		
		
	}

	@Override
	public void ReadEventsFromQueue() throws MQException, MQDataException, IOException, InterruptedException {
		TaskStatus(IMQPCFConstants.TASK_STARTING);
		
		while ((TaskStatus() == IMQPCFConstants.TASK_STARTING)
				|| (TaskStatus() == IMQPCFConstants.TASK_RUNNING)) {
			
			if (TaskStatus() == IMQPCFConstants.TASK_STARTING) {
				TaskStatus(IMQPCFConstants.TASK_RUNNING);
			}
			
			if (Thread.interrupted()) {
				TaskStatus(IMQPCFConstants.TASK_STOPPING);
			}
						
			try {		
				MQMessage message = new MQMessage();
				Queue().get (message, GetMessageOptions());
	
				if (message.format.equals(MQConstants.MQFMT_PCF)) {
					calcDayBucket(message.putDateTime);
					
					PCFMessage pcf = new PCFMessage (message);
					Enumeration<PCFParameter> gparms = pcf.getParameters();

					grpRecords: while (gparms.hasMoreElements()) {
						PCFParameter grpPCFParams = gparms.nextElement(); 
						//log.debug("Param: {}, Value: {}", grpPCFParams.getParameter(), grpPCFParams.getValue());

						switch (grpPCFParams.getType()) {						
							case MQConstants.MQCFT_INTEGER:
								//log.debug("Integer", grpPCFParams.getType());
								
								if (grpPCFParams.getParameter() == MQConstants.	MQIAMO_MONITOR_FLAGS_NONE) {
									CPUMetric(grpPCFParams);									
								}
								if (grpPCFParams.getParameter() == MQConstants.MQIAMO_MONITOR_UNIT) {
									SystemCPU(grpPCFParams);	
								}
								if (grpPCFParams.getParameter() == MQConstants.MQIAMO_MONITOR_DELTA) {
									Delta(grpPCFParams);
								}
								break;
								
							case MQConstants.MQCFT_INTEGER64:
								//log.debug("Integer64", grpPCFParams.getType());
								
								if (grpPCFParams.getParameter() == MQConstants.MQIAMO64_MONITOR_INTERVAL) {
									IntervalTime(grpPCFParams);	
								}								
								break;
								
							case MQConstants.MQCFT_STRING:
								//log.debug("String", grpPCFParams.getType());
								break;
								
							default:
								log.info("Unknown property: {}", grpPCFParams.getType());
								break;
						}
					}					
				}
				
				DeleteMessagesUnderCursor();
				SetGMOOptions(MQConstants.MQGMO_BROWSE_NEXT);
								
			} catch (MQException e) {
				if (e.getReason() == MQConstants.MQRC_NO_MSG_AVAILABLE) {
					log.debug("No more CPU event messages");
					RetCode(e.getReason());
					
				} else {
					if (Thread.interrupted()) {
						log.error("Thread interupted");						
					}
					if (e.getReason() != MQConstants.MQRC_UNEXPECTED_ERROR) {
						RetCode(e.getReason());
						log.error("MQ error : {} reasonCode {}", e.getMessage(), e.reasonCode);
						
					} else {
						RetCode(IMQPCFConstants.OKAY);						
					}
					TaskStatus(IMQPCFConstants.TASK_STOPPING);
					
				}				
				
			} catch (MQDataException e) {
					log.warn("Unknown property in channel event messages");
					RetCode(e.getReason());
			}
    		
			
		} // end of while 
		
		TaskStatus(IMQPCFConstants.TASK_STOPPED);
		RetCode(IMQPCFConstants.OKAY);
		log.debug("Channel task stopped");

	}

	/*
	 * CPU Metric
	 */
	private void CPUMetric(PCFParameter grpPCFParams) {

		StringBuilder sb = new StringBuilder();
		sb.append(lookupcpu);
		sb.append("_");
		sb.append(QueueManagerName());
		sb.append("_");
		sb.append(EventType());					
		sb.append("_");
		sb.append(grpPCFParams.getParameter());					
		String label = sb.toString();

		AtomicInteger v = this.CPUEventsMap.get(label);
		if (v == null) {
			this.CPUEventsMap.put(label, 
				meterRegistry.gauge(lookupcpu + "_User", 
				Tags.of("queueManagerName", QueueManagerName(),
						"type",EventType(),
						"cpuType", "User",
				        "unit","Percentage"),
					new AtomicInteger((int)grpPCFParams.getValue()))
				);
			log.debug("CPU User metrics created");
		} else {
			v.set((int)grpPCFParams.getValue());
		}									
		
	}
	
	private void SystemCPU(PCFParameter grpPCFParams) {
		
		StringBuilder sb = new StringBuilder();
		sb.append(lookupcpu);
		sb.append("_");
		sb.append(QueueManagerName());
		sb.append("_");
		sb.append(EventType());					
		sb.append("_");
		sb.append(grpPCFParams.getParameter());					
		String label = sb.toString();

		AtomicInteger v = this.CPUEventsMap.get(label);
		if (v == null) {
			this.CPUEventsMap.put(label, 
				meterRegistry.gauge(lookupcpu + "_System", 
				Tags.of("queueManagerName", QueueManagerName(),
						"type",EventType(),
						"cpuType", "System",
						"unit","Percentage"),
					new AtomicInteger((int)grpPCFParams.getValue()))
				);
			log.debug("CPU System metrics created");
		} else {
			v.set((int)grpPCFParams.getValue());
		}									
		
	}

	private void IntervalTime(PCFParameter grpPCFParams) {
		
		StringBuilder sb = new StringBuilder();
		sb.append(lookupcpu);
		sb.append("_");
		sb.append(QueueManagerName());
		sb.append("_");
		sb.append(EventType());					
		sb.append("_");
		sb.append(grpPCFParams.getParameter());					
		String label = sb.toString();

		AtomicLong v = this.CPUIntervalMap.get(label);
		if (v == null) {
			this.CPUIntervalMap.put(label, 
				meterRegistry.gauge(lookupcpu + "_Interval", 
				Tags.of("queueManagerName", QueueManagerName(),
						"type",EventType(),
						"unit","Thousandths"),
					new AtomicLong((long)grpPCFParams.getValue()))
				);
			log.debug("CPU Interval time metrics created");
		} else {
			v.set((long)grpPCFParams.getValue());
		}									
		
	}

	/*
	 * DELTA
	 */
	private void Delta(PCFParameter grpPCFParams) {
		
		StringBuilder sb = new StringBuilder();
		sb.append(lookupcpu);
		sb.append("_");
		sb.append(QueueManagerName());
		sb.append("_");
		sb.append(EventType());					
		sb.append("_");
		sb.append(grpPCFParams.getParameter());					
		String label = sb.toString();

		AtomicInteger v = this.CPUEventsMap.get(label);
		if (v == null) {
			this.CPUEventsMap.put(label, 
				meterRegistry.gauge(lookupcpu + "_RAM", 
				Tags.of("queueManagerName", QueueManagerName(),
						"type",EventType(),
						"unit","Units"),
					new AtomicInteger((int)grpPCFParams.getValue()))
				);
			log.debug("CPU RAM metrics created");
		} else {
			v.set((int)grpPCFParams.getValue());
		}									
		
	}
	
	/*
	 * Open the queue for reading
	 */
	@Override
	public void OpenQueueForReading() throws MQException {

		log.debug("Opening queue for reading");
		int openOptions = MQConstants.MQOO_INPUT_AS_Q_DEF |
				MQConstants.MQOO_BROWSE |
				MQConstants.MQOO_FAIL_IF_QUIESCING;			

		GetMessageOptions(new MQGetMessageOptions());		
		Queue(QueueManager().accessQueue(QueueName(), openOptions));
		SetGMOOptions(MQConstants.MQGMO_BROWSE_FIRST);
		
	}

	/*
	 * Delete the message 
	 */
	@Override
	public void DeleteMessagesUnderCursor() throws MQException {
		/*
		 * For the queue we are looking for ...
		 *    if we want to, remove the message from the accounting queue
		 */
		if (!Browse()) {
			MQMessage message = new MQMessage();		
			GetMessageOptions().options = MQConstants.MQGMO_MSG_UNDER_CURSOR 
					| MQConstants.MQGMO_WAIT
					| MQConstants.MQGMO_FAIL_IF_QUIESCING
					| MQConstants.MQGMO_CONVERT;

			try {
				Queue().get (message, GetMessageOptions());
				log.debug("Message reoved ...." );

			} catch (Exception e) {
				/*
				 * If we fail, then someone else might has removed
				 * the message, so continue
				 */
			}
		} else {
			QueueManager().commit();

		}
		
	}

    /*
     * Set the GetMessageOptions
     */
    private void SetGMOOptions(int firstNext) {
    	
		int options = MQConstants.MQGMO_WAIT
				| MQConstants.MQGMO_FAIL_IF_QUIESCING
				| MQConstants.MQGMO_CONVERT;
		GetMessageOptions().waitInterval = WaitInterval();
		
		if (Browse()) {
			if (firstNext == MQConstants.MQGMO_BROWSE_FIRST) {
				options += MQConstants.MQGMO_BROWSE_FIRST;
				
			} else {
				if (firstNext == MQConstants.MQGMO_BROWSE_NEXT) {
					options += MQConstants.MQGMO_BROWSE_NEXT;					
				}
			}

		} else {
			options = MQConstants.MQGMO_WAIT
					| MQConstants.MQGMO_FAIL_IF_QUIESCING
					| MQConstants.MQGMO_CONVERT
					| MQConstants.MQGMO_SYNCPOINT;
		}
		GetMessageOptions().options = options;
		
	}

    /*
     * Calculate the dates
     */    
	private void calcDayBucket(GregorianCalendar putDateTime) {
		
		ZonedDateTime zdt;
		Instant instant;

		this.cal = putDateTime;
		zdt = this.cal.toZonedDateTime();
		instant = zdt.toInstant();
		ZonedDateTime z = ZonedDateTime.ofInstant(instant, ZoneOffset.UTC);

		Hour(this.cal.get(Calendar.HOUR_OF_DAY)); 
		Day(this.cal.get(Calendar.DAY_OF_MONTH));
		Month((this.cal.get(Calendar.MONTH) + 1)); // Month is indexed from 0 !!, so, JAN = 0, FEB = 1 etc 
		Year(this.cal.get(Calendar.YEAR));
				
	}
	
	@Override
	@PreDestroy
	public void Destroy() throws MQException, InterruptedException {
    	log.info("Destroy Channel Events");
    	int maxCount = 0;
    	
    	do {
    		TaskStatus(IMQPCFConstants.TASK_STOPPING);
	    	maxCount++;
	    	
    	} while (TaskStatus() == IMQPCFConstants.TASK_RUNNING || maxCount > 10);
    	
    	try {
	    	if (Queue() != null) {
	    		MetricsQueueManager().CloseQueue(Queue());
	    	}
	    	if (QueueManager() != null) {
	    		MetricsQueueManager().CloseConnection(QueueManager());
	    	}
	    	
    	} catch (Exception e) {
    		// continue if we can an error
    	}
		
	}

	
}
